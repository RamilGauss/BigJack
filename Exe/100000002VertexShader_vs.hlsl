#if 0
	***	hlms_shadowmap4_uv_min_x_int	0
	***	hlms_uv_count0	2
	***	hlms_pose	0
	***	uv_emissive	0
	***	first_valid_detail_map_nm	4
	***	fresnel_scalar	0
	***	hlms_shadowmap4_uv_max_y_int	1
	***	hlms_uv_count	1
	***	pcf_iterations	4
	***	hlms_shadowmap4_uv_max_y_fract	0
	***	uv_detail_nm1	0
	***	hlms_lights_spotparams	0
	***	uv_detail_nm2	0
	***	hlms_tex_gather	1
	***	BRDF_Default	1
	***	hlms_shadowmap2_array_idx	0
	***	hlms_shadowmap3_uv_max_x_fract	0
	***	set0_texture_slot_end	3
	***	uv_specular	0
	***	hlms_shadowmap1_uv_min_x_fract	0
	***	hlms_shadowmap2_uv_min_x_fract	50000
	***	fast_shader_build_hack	1
	***	glsl	635204550
	***	hlms_shadowmap2_uv_max_y_fract	42857
	***	hlms_shadowmap0_uv_max_x_fract	0
	***	hlms_shadowmap2_uv_max_y_int	0
	***	hlms_high_quality	0
	***	hlms_num_shadow_map_lights	5
	***	hlms_lights_directional	3
	***	hlms_shadowmap0_uv_min_y_fract	0
	***	samplerStateStart	3
	***	hlms_shadowmap1_uv_min_y_fract	28571
	***	alpha_test	0
	***	hlms_shadowmap4_light_idx	2
	***	GGX_height_correlated	1
	***	hlms_shadowmap2	0
	***	hlms_shadowmap0_light_idx	0
	***	glsles	1070293233
	***	metallic_workflow	0
	***	hlms_shadowmap4	0
	***	hw_gamma_write	1
	***	hlms_shadowmap0_uv_min_y_int	0
	***	uv_detail_weight	0
	***	hlms_shadowmap0_uv_max_x_int	1
	***	hlms_shadowmap4_array_idx	0
	***	hlms_shadowmap1_uvs_fulltex	1
	***	hlms_alpha_to_coverage	0
	***	cubemaps_as_diffuse_gi	1
	***	hlms_shadowmap1_uv_max_y_fract	42857
	***	uv_detail_nm3	0
	***	hlms_shadowmap2_uv_max_x_int	1
	***	hlms_pssm_splits	3
	***	hlms_shadowmap0_uv_min_x_int	0
	***	hlms_pose_normals	0
	***	hlms_pose_half	0
	***	hlms_shadowmap1_light_idx	0
	***	hlms_shadowmap0_uv_min_x_fract	0
	***	hlms_lights_spot	3
	***	shadowmap2_is_directional_light	1
	***	hlms_shadowmap3_array_idx	0
	***	uv_normal	0
	***	hlms_alphablend	0
	***	hlms_num_shadow_map_textures	1
	***	hlms_shadowmap1_array_idx	0
	***	hlms_shadowmap4_uvs_fulltex	1
	***	num_textures	1
	***	hlslvk	1841745752
	***	hlms_shadowmap1_uv_min_x_int	0
	***	shadowmap4_is_directional_light	1
	***	uv_detail3	0
	***	hlms_shadow_uses_depth_texture	1
	***	normal_map	0
	***	hlms_shadowmap1	0
	***	hlms_shadowmap2_uv_max_x_fract	0
	***	pcf	3
	***	uv_detail1	0
	***	fresnel_workflow	0
	***	hlms_shadowmap2_uv_min_y_fract	28571
	***	shadowmap1_is_directional_light	1
	***	hlms_shadowmap4_uv_max_x_fract	0
	***	perceptual_roughness	1
	***	alpha_test_shadow_caster_only	0
	***	materials_per_buffer	2
	***	hw_gamma_read	1
	***	hlms_skeleton	0
	***	hlms_shadowmap1_uv_max_y_int	0
	***	hlms_shadowmap3_uv_min_y_int	0
	***	hlms_shadowmap2_uv_min_x_int	0
	***	hlms_shadowmap1_uv_max_x_int	0
	***	syntax	-334286542
	***	hlms_lights_point	3
	***	diffuse_map_sampler	0
	***	hlms_shadowmap3_uv_max_x_int	1
	***	metal	-1698855755
	***	s_lights_directional_non_caster	3
	***	hlms_shadowmap4_uv_min_x_fract	0
	***	uv_detail0	0
	***	uv_diffuse	0
	***	diffuse_map	1
	***	hlms_pssm_blend	1
	***	uv_detail_nm0	0
	***	hlms_shadowmap3_uv_max_y_int	0
	***	hlms_shadowmap4_uv_min_y_int	0
	***	hlms_shadowmap3_light_idx	1
	***	diffuse_map_idx	0
	***	hlms_lights_attenuation	0
	***	hlms_shadowmap4_uv_min_y_fract	71428
	***	hlms_shadowmap2_light_idx	0
	***	shadowmap0_is_directional_light	1
	***	hlms_shadowmap4_uv_max_x_int	1
	***	hlms_shadowmap0_array_idx	0
	***	hlms_render_depth_only	0
	***	hlms_shadowmap3_uv_min_x_fract	0
	***	uv_detail2	0
	***	hlms_shadowmap3_uv_min_x_int	0
	***	textureMaps0	3
	***	hlms_shadowmap1_uv_max_x_fract	50000
	***	hlms_shadowmap0_uvs_fulltex	1
	***	hlms_qtangent	1
	***	hlms_shadowmap1_uv_min_y_int	0
	***	uv_roughness	0
	***	hlms_shadowmap3_uvs_fulltex	1
	***	shadowmap3_is_directional_light	1
	***	receive_shadows	1
	***	hlms_shadowmap3_uv_min_y_fract	42857
	***	hlms_pssm_fade	1
	***	clear_coat	0
	***	hlms_shadowmap0	0
	***	hlms_shadowmap3	0
	***	needs_view_dir	1
	***	hlms_shadowmap2_uvs_fulltex	1
	***	set1_texture_slot_end	4
	***	use_planar_reflections	0
	***	texShadowMap0	2
	***	hlms_shadowmap2_uv_min_y_int	0
	***	ltc_texture_available	1
	***	num_samplers	1
	***	glslvk	-338983575
	***	hlms_shadowmap0_uv_max_y_fract	28571
	***	hlsl	-334286542
	***	hlms_shadowmap0_uv_max_y_int	0
	***	hlms_shadowmap3_uv_max_y_fract	71428
	***	normal_weight	0
	DONE DUMPING PROPERTIES
	DONE DUMPING PIECES
#endif

//#include "SyntaxHighlightingMisc.h"


#define ushort uint
#define ushort3 uint3
#define ushort4 uint4
#define ogre_float4x3 float4x3

//Short used for read operations. It's an int in GLSL & HLSL. An ushort in Metal
#define rshort int
#define rshort2 int2
#define rint int
//Short used for write operations. It's an int in GLSL. An ushort in HLSL & Metal
#define wshort2 uint2
#define wshort3 uint3

#define toFloat3x3( x ) ((float3x3)(x))
#define buildFloat3x3( row0, row1, row2 ) transpose( float3x3( row0, row1, row2 ) )

#define min3( a, b, c ) min( a, min( b, c ) )
#define max3( a, b, c ) max( a, max( b, c ) )

#define INLINE
#define NO_INTERPOLATION_PREFIX nointerpolation
#define NO_INTERPOLATION_SUFFIX

#define PARAMS_ARG_DECL
#define PARAMS_ARG

#define floatBitsToUint(x) asuint(x)
#define uintBitsToFloat(x) asfloat(x)
#define floatBitsToInt(x) asint(x)
#define fract frac
#define lessThan( a, b ) (a < b)

#define inVs_vertexId input.vertexId
#define inVs_vertex input.vertex
#define inVs_normal input.normal
#define inVs_tangent input.tangent
#define inVs_binormal input.binormal
#define inVs_blendWeights input.blendWeights
#define inVs_blendIndices input.blendIndices
#define inVs_qtangent input.qtangent
#define inVs_colour input.colour

	#define inVs_drawId input.drawId


#define finalDrawId input.drawId


	#define inVs_uv0 input.uv0

#define outVs_Position outVs.gl_Position
#define outVs_viewportIndex outVs.gl_ViewportIndex
#define outVs_clipDistance0 outVs.gl_ClipDistance0.x

#define gl_SampleMaskIn0 gl_SampleMask
#define interpolateAtSample( interp, subsample ) EvaluateAttributeAtSample( interp, subsample )
#define findLSB firstbitlow
#define findMSB firstbithigh
#define mod( a, b ) (a - b * floor(a / b))

#define outPs_colour0 outPs.colour0
#define OGRE_Sample( tex, sampler, uv ) tex.Sample( sampler, uv )
#define OGRE_SampleLevel( tex, sampler, uv, lod ) tex.SampleLevel( sampler, uv, lod )
#define OGRE_SampleArray2D( tex, sampler, uv, arrayIdx ) tex.Sample( sampler, float3( uv, arrayIdx ) )
#define OGRE_SampleArray2DLevel( tex, sampler, uv, arrayIdx, lod ) tex.SampleLevel( sampler, float3( uv, arrayIdx ), lod )
#define OGRE_SampleArrayCubeLevel( tex, sampler, uv, arrayIdx, lod ) tex.SampleLevel( sampler, float4( uv, arrayIdx ), lod )
#define OGRE_SampleGrad( tex, sampler, uv, ddx, ddy ) tex.SampleGrad( sampler, uv, ddx, ddy )
#define OGRE_SampleArray2DGrad( tex, sampler, uv, arrayIdx, ddx, ddy ) tex.SampleGrad( sampler, float3( uv, arrayIdx ), ddx, ddy )
#define OGRE_ddx( val ) ddx( val )
#define OGRE_ddy( val ) ddy( val )
#define OGRE_Load2D( tex, iuv, lod ) tex.Load( int3( iuv, lod ) )
#define OGRE_LoadArray2D( tex, iuv, arrayIdx, lod ) tex.Load( int4( iuv, arrayIdx, lod ) )
#define OGRE_Load2DMS( tex, iuv, subsample ) tex.Load( iuv, subsample )

#define OGRE_Load3D( tex, iuv, lod ) tex.Load( int4( iuv, lod ) )

#define bufferFetch( buffer, idx ) buffer.Load( idx )
#define bufferFetch1( buffer, idx ) buffer.Load( idx ).x

#define structuredBufferFetch( buffer, idx ) buffer[idx]


	#define ReadOnlyBuffer( slot, varType, varName ) StructuredBuffer<varType> varName : register(t##slot)
	#define readOnlyFetch( bufferVar, idx ) bufferVar[idx]
	#define readOnlyFetch1( bufferVar, idx ) bufferVar[idx].x


#define OGRE_Texture3D_float4 Texture3D

#define OGRE_ArrayTex( declType, varName, arrayCount ) declType varName[arrayCount]

#define OGRE_SAMPLER_ARG_DECL( samplerName ) , SamplerState samplerName
#define OGRE_SAMPLER_ARG( samplerName ) , samplerName

#define CONST_BUFFER( bufferName, bindingPoint ) cbuffer bufferName : register(b##bindingPoint)
#define CONST_BUFFER_STRUCT_BEGIN( structName, bindingPoint ) cbuffer structName : register(b##bindingPoint) { struct _##structName
#define CONST_BUFFER_STRUCT_END( variableName ) variableName; }

#define FLAT_INTERPOLANT( decl, bindingPoint ) nointerpolation decl : TEXCOORD##bindingPoint
#define INTERPOLANT( decl, bindingPoint ) decl : TEXCOORD##bindingPoint

#define OGRE_OUT_REF( declType, variableName ) out declType variableName
#define OGRE_INOUT_REF( declType, variableName ) inout declType variableName

#define OGRE_ARRAY_START( type ) {
#define OGRE_ARRAY_END }



	
		#define worldViewMat worldView
	

	
float4x4 UNPACK_MAT4( StructuredBuffer<float4> matrixBuf, uint pixelIdx )
{
	float4 row1 = matrixBuf[int(pixelIdx << 2u)];
	float4 row2 = matrixBuf[int((pixelIdx << 2u) + 1u)];
	float4 row3 = matrixBuf[int((pixelIdx << 2u) + 2u)];
	float4 row4 = matrixBuf[int((pixelIdx << 2u) + 3u)];

	return transpose( float4x4( row1, row2, row3, row4 ) );
}

	
float4x3 UNPACK_MAT4x3( StructuredBuffer<float4> matrixBuf, uint pixelIdx )
{
	float4 row1 = matrixBuf[int(pixelIdx << 2u)];
	float4 row2 = matrixBuf[int((pixelIdx << 2u) + 1u)];
	float4 row3 = matrixBuf[int((pixelIdx << 2u) + 2u)];

	return transpose( float3x4( row1, row2, row3 ) );
}


	// START UNIFORM DECLARATION
	
struct ShadowReceiverData
{
	float4x4 texViewProj;

	float2 shadowDepthRange;
	float normalOffsetBias;
	float padding;
	float4 invShadowMapSize;
};

struct Light
{
	
		float3 position;
		uint lightMask;
	
	float4 diffuse;		//.w contains numNonCasterDirectionalLights
	float3 specular;

	float3 attenuation;
	//Spotlights:
	//  spotDirection.xyz is direction
	//  spotParams.xyz contains falloff params
	float4 spotDirection;
	float4 spotParams;


#define lightTexProfileIdx spotDirection.w
};

#define numNonCasterDirectionalLights lights[0].diffuse.w

#define areaLightDiffuseMipmapStart areaApproxLights[0].diffuse.w
#define areaLightNumMipmapsSpecFactor areaApproxLights[0].specular.w

#define numAreaApproxLights areaApproxLights[0].doubleSided.y
#define numAreaApproxLightsWithMask areaApproxLights[0].doubleSided.z

#define numAreaLtcLights areaLtcLights[0].points[0].w
#define numAreaLtcLights areaLtcLights[0].points[0].w

struct AreaLight
{
	
		float3 position;
		uint lightMask;
	
	float4 diffuse;		//[0].w contains diffuse mipmap start
	float4 specular;	//[0].w contains mipmap scale
	float4 attenuation;	//.w contains texture array idx
	//Custom 2D Shape:
	//  direction.xyz direction
	//  direction.w invHalfRectSize.x
	//  tangent.xyz tangent
	//  tangent.w invHalfRectSize.y
	float4 direction;
	float4 tangent;
	float4 doubleSided;	//.y contains numAreaApproxLights
						//.z contains numAreaApproxLightsWithMask
	
};

struct AreaLtcLight
{
	
		float3 position;
		uint lightMask;
	
	float4 diffuse;			//.w contains attenuation range
	float4 specular;		//.w contains doubleSided
	float4 points[4];		//.w contains numAreaLtcLights
							//points[1].w, points[2].w, points[3].w contain obbFadeFactorLtc.xyz
	
};





//Uniforms that change per pass
CONST_BUFFER_STRUCT_BEGIN( PassBuffer, 0 )
{
	//Vertex shader (common to both receiver and casters)

	float4x4 viewProj;







	//Vertex shader
	float4x4 view;
	ShadowReceiverData shadowRcv[5];

	

	//-------------------------------------------------------------------------

	//Pixel shader
	float3x3 invViewMatCubemap;

	float padding; //Compatibility with GLSL


	float4 pccVctMinDistance_invPccVctInvDistance_rightEyePixelStartX_envMapNumMipmaps;

	float4 aspectRatio_planarReflNumMips_unused2;

	float2 invWindowRes;
	float2 windowResolution;









	float pssmSplitPoints0;
	float pssmSplitPoints1;
	float pssmSplitPoints2;

	float pssmBlendPoints0;
	float pssmBlendPoints1;

	float pssmFadePoint;


	Light lights[3];
	
	
// !use_light_buffers





	



	
	

	

#define pccVctMinDistance		pccVctMinDistance_invPccVctInvDistance_rightEyePixelStartX_envMapNumMipmaps.x
#define invPccVctInvDistance	pccVctMinDistance_invPccVctInvDistance_rightEyePixelStartX_envMapNumMipmaps.y
#define rightEyePixelStartX		pccVctMinDistance_invPccVctInvDistance_rightEyePixelStartX_envMapNumMipmaps.z
#define envMapNumMipmaps		pccVctMinDistance_invPccVctInvDistance_rightEyePixelStartX_envMapNumMipmaps.w

#define aspectRatio			aspectRatio_planarReflNumMips_unused2.x
#define planarReflNumMips	aspectRatio_planarReflNumMips_unused2.y
}
CONST_BUFFER_STRUCT_END( passBuf );



#define light0Buf		passBuf
#define light1Buf		passBuf
#define light2Buf		passBuf

// use_light_buffers


	
	
	// END UNIFORM DECLARATION

	
		
float3 xAxis( float4 qQuat )
{
	float fTy  = 2.0 * qQuat.y;
	float fTz  = 2.0 * qQuat.z;
	float fTwy = fTy * qQuat.w;
	float fTwz = fTz * qQuat.w;
	float fTxy = fTy * qQuat.x;
	float fTxz = fTz * qQuat.x;
	float fTyy = fTy * qQuat.y;
	float fTzz = fTz * qQuat.z;

	return float3( 1.0-(fTyy+fTzz), fTxy+fTwz, fTxz-fTwy );
}

		
	

    
			
				
					#define shadowMap0LightDir light0Buf.lights[0].position.xyz
				
				
				
			
				
					#define shadowMap1LightDir light0Buf.lights[0].position.xyz
				
				
				
			
				
					#define shadowMap2LightDir light0Buf.lights[0].position.xyz
				
				
				
			
				
					#define shadowMap3LightDir light0Buf.lights[1].position.xyz
				
				
				
			
				
					#define shadowMap4LightDir light0Buf.lights[2].position.xyz
				
				
				
			
			
				#define hlms_shadowmap0_uv_min float2( 0.0, 0.0 )
				#define hlms_shadowmap0_uv_max float2( 1.0, 0.28571 )
				
					
						#define hlms_shadowmap0_uv_param , hlms_shadowmap0_uv_min, hlms_shadowmap0_uv_max
					
				
			
				#define hlms_shadowmap1_uv_min float2( 0.0, 0.28571 )
				#define hlms_shadowmap1_uv_max float2( 0.50000, 0.42857 )
				
					
						#define hlms_shadowmap1_uv_param , hlms_shadowmap1_uv_min, hlms_shadowmap1_uv_max
					
				
			
				#define hlms_shadowmap2_uv_min float2( 0.50000, 0.28571 )
				#define hlms_shadowmap2_uv_max float2( 1.0, 0.42857 )
				
					
						#define hlms_shadowmap2_uv_param , hlms_shadowmap2_uv_min, hlms_shadowmap2_uv_max
					
				
			
				#define hlms_shadowmap3_uv_min float2( 0.0, 0.42857 )
				#define hlms_shadowmap3_uv_max float2( 1.0, 0.71428 )
				
					
						#define hlms_shadowmap3_uv_param , hlms_shadowmap3_uv_min, hlms_shadowmap3_uv_max
					
				
			
				#define hlms_shadowmap4_uv_min float2( 0.0, 0.71428 )
				#define hlms_shadowmap4_uv_max float2( 1.0, 1.0 )
				
					
						#define hlms_shadowmap4_uv_param , hlms_shadowmap4_uv_min, hlms_shadowmap4_uv_max
					
				
			

			
		
			// Perform normal offset bias. See https://github.com/OGRECave/ogre-next/issues/100
			INLINE float3 getNormalOffsetBias( float3 worldNormal, float3 viewSpaceNormal,
											   float3 lightDir, float shadowMapTexSize,
											   float depthRange, float normalOffsetBias
			
											   )
			
			{
				float tmpNdotL = saturate( dot( lightDir.xyz, viewSpaceNormal.xyz ) );

				

				return ( ( 1.0f - tmpNdotL ) * normalOffsetBias * worldNormal.xyz * shadowMapTexSize );
			}
		
			// Perform normal offset bias. See https://github.com/OGRECave/ogre-next/issues/100
			INLINE float3 getNormalOffsetBias( float3 worldNormal, float3 viewSpaceNormal,
											   float3 lightDir, float shadowMapTexSize,
											   float depthRange, float normalOffsetBias
			
											   , float2 minUV, float2 maxUV )
			
			{
				float tmpNdotL = saturate( dot( lightDir.xyz, viewSpaceNormal.xyz ) );

				
					shadowMapTexSize /= maxUV.x - minUV.x;
				

				return ( ( 1.0f - tmpNdotL ) * normalOffsetBias * worldNormal.xyz * shadowMapTexSize );
			}
		
	
		



struct VS_INPUT
{
	float4 vertex : POSITION;

	float4 qtangent : NORMAL;








	float2 uv0 : TEXCOORD0;
	uint drawId : DRAWID;
	
};

struct PS_INPUT
{
	
	
		
			FLAT_INTERPOLANT( ushort drawId, 0 );
		
	

	
		
			INTERPOLANT( float3 pos, 1 );
			INTERPOLANT( float3 normal, 2 );
			
		
		
			INTERPOLANT( float2 uv0, 3 );

		
			
				
					INTERPOLANT( float4 posL0, 4 );
				
			
				
					INTERPOLANT( float4 posL1, 5 );
				
			
				
					INTERPOLANT( float4 posL2, 6 );
				
			
				
					INTERPOLANT( float4 posL3, 7 );
				
			
				
					INTERPOLANT( float4 posL4, 8 );
				
			
		

		INTERPOLANT( float depth, 9 );
		

		
	
	

	float4 gl_Position: SV_Position;

	

	
	
	
	
};

// START UNIFORM D3D DECLARATION
ReadOnlyBuffer( 0, float4, worldMatBuf );

// END UNIFORM D3D DECLARATION

PS_INPUT main( VS_INPUT input )
{
	PS_INPUT outVs;

	
	
	// Define inputPos using inVs_vertex.
	
		#define inputPos inVs_vertex
	

	// Define inputNormal and inputTangent using inVs_normal, inVs_tangent, inVs_qtangent
	
		//Decode qTangent to TBN with reflection
		float3 inputNormal	= xAxis( normalize( inVs_qtangent ) );
		
	

	
		ogre_float4x3 worldMat = UNPACK_MAT4x3( worldMatBuf, inVs_drawId << 1u);
		
			float4x4 worldView = UNPACK_MAT4( worldMatBuf, (inVs_drawId << 1u) + 1u );
		

		float4 worldPos = float4( mul(inVs_vertex, worldMat).xyz, 1.0f );
		
			// We need worldNorm for normal offset bias
			float3 worldNorm = mul( inputNormal, toFloat3x3( worldMat ) ).xyz;
		
	

	

	

	
	
	
	//Lighting is in view space
		outVs.pos		= mul( inputPos, worldViewMat ).xyz;
		outVs.normal	= mul( inputNormal, toFloat3x3( worldViewMat ) );
	
	
        
			
				outVs_Position = mul( worldPos, passBuf.viewProj );
			
		
	


	
				float3 normalOffsetBias = float3( 0, 0, 0 );
				
					
						
							normalOffsetBias = getNormalOffsetBias( worldNorm, outVs.normal, shadowMap0LightDir,
																	passBuf.shadowRcv[0].invShadowMapSize.x,
																	passBuf.shadowRcv[0].shadowDepthRange.y,
																	passBuf.shadowRcv[0].normalOffsetBias
																	hlms_shadowmap0_uv_param );
						
						outVs.posL0 = mul( float4(worldPos.xyz + normalOffsetBias, 1.0f), passBuf.shadowRcv[0].texViewProj );

						

						
					
				
					
						
							normalOffsetBias = getNormalOffsetBias( worldNorm, outVs.normal, shadowMap1LightDir,
																	passBuf.shadowRcv[1].invShadowMapSize.x,
																	passBuf.shadowRcv[1].shadowDepthRange.y,
																	passBuf.shadowRcv[1].normalOffsetBias
																	hlms_shadowmap1_uv_param );
						
						outVs.posL1 = mul( float4(worldPos.xyz + normalOffsetBias, 1.0f), passBuf.shadowRcv[1].texViewProj );

						

						
					
				
					
						
							normalOffsetBias = getNormalOffsetBias( worldNorm, outVs.normal, shadowMap2LightDir,
																	passBuf.shadowRcv[2].invShadowMapSize.x,
																	passBuf.shadowRcv[2].shadowDepthRange.y,
																	passBuf.shadowRcv[2].normalOffsetBias
																	hlms_shadowmap2_uv_param );
						
						outVs.posL2 = mul( float4(worldPos.xyz + normalOffsetBias, 1.0f), passBuf.shadowRcv[2].texViewProj );

						

						
					
				
					
						
							normalOffsetBias = getNormalOffsetBias( worldNorm, outVs.normal, shadowMap3LightDir,
																	passBuf.shadowRcv[3].invShadowMapSize.x,
																	passBuf.shadowRcv[3].shadowDepthRange.y,
																	passBuf.shadowRcv[3].normalOffsetBias
																	hlms_shadowmap3_uv_param );
						
						outVs.posL3 = mul( float4(worldPos.xyz + normalOffsetBias, 1.0f), passBuf.shadowRcv[3].texViewProj );

						

						
					
				
					
						
							normalOffsetBias = getNormalOffsetBias( worldNorm, outVs.normal, shadowMap4LightDir,
																	passBuf.shadowRcv[4].invShadowMapSize.x,
																	passBuf.shadowRcv[4].shadowDepthRange.y,
																	passBuf.shadowRcv[4].normalOffsetBias
																	hlms_shadowmap4_uv_param );
						
						outVs.posL4 = mul( float4(worldPos.xyz + normalOffsetBias, 1.0f), passBuf.shadowRcv[4].texViewProj );

						

						
					
				

				outVs.depth = outVs_Position.w;
			
	

	/// hlms_uv_count will be 0 on shadow caster passes w/out alpha test
	
		outVs.uv0 = inVs_uv0;


	
		outVs.drawId = inVs_drawId;
	


	

	

	

	

	return outVs;
}
